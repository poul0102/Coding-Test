# 문제
단어 변환
<https://school.programmers.co.kr/learn/courses/30/lessons/43163>


## DFS
```
class Solution {
    
    String target;      // 목표 단어
    String[] words;     // 단어 목록
    boolean[] visited;  // 방문 여부
    int answer = Integer.MAX_VALUE; // 최소 단계 
    
    public int solution(String begin, String target, String[] words) {
        this.target = target;
        this.words = words;
        visited = new boolean[words.length];
        
        dfs(begin, 0);
        
        return answer == Integer.MAX_VALUE ? 0 : answer;
    }
    
    void dfs(String str, int count) {
        // 목표 단어 도달 시 최소값 갱신
        if (str.equals(target)) {
            answer = Math.min(answer, count);
            return;
        }
        
        // 다음 변환 가능한 단어 탐색
        for (int i = 0; i < words.length; i++) {
              if (!visited[i] && isNext(str, words[i])) {
                  visited[i] = true;
                  dfs(words[i], count + 1);
                  visited[i] = false;
              }
        }
    }
    
    // 단어 변환 가능 여부 확인
    boolean isNext(String str, String next) {
        int count = 0;
        
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) != next.charAt(i)) {
                count++;
            }
            if (count > 1) return false;
        }
        return true;
    }
}
```


## BFS
```
import java.util.*;

class Solution {
    public int solution(String begin, String target, String[] words) {
        int answer = 0;
        
        Queue<String> q = new LinkedList<>();
        boolean[] visited = new boolean[words.length];  // 방문 여부
        
        q.offer(begin);
        
        while (!q.isEmpty()) {
            int size = q.size();    // 현재 레벨에 있는 노드 개수
            
            // 현재 레벨에 있는 노드만 처리
            for (int i = 0; i < size; i++) {
                String current = q.poll();
                
                if (current.equals(target)) return answer;

                for (int j = 0; j < words.length; j++) {
                    if (!visited[j] && isNext(current, words[j])) {
                        visited[j] = true;
                        q.offer(words[j]);
                    }
                }
            }
            answer++;
        }
        
        return 0;
    }
    
    // 단어 변환 가능 여부 확인
    boolean isNext(String str, String next) {
        int count = 0;
        
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) != next.charAt(i)) {
                count++;
            }
            if (count > 1) return false;
        }
        return true;
    }
}
```

해당 문제는 최소 변환 단계(최단 거리)를 요구하는 문제이기에 BFS 풀이가 더 낫다.